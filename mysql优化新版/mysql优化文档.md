#表的优化与列类型选择
##表的优化：
1.定长与变成分离  
如 id int，占4个字节，char(4)占4个字符长度，也是定长,time即每一个单元值的字节是固定的。  
核心且常用字段，宜建成定长，放在一张表。  

而varchar,text,blob，这种变成字段，适合单放一张表，用主键与核心表关联起来。 

2.常用字段和不常用字段要分离  
需要结合网站具体的业务来分析，分析字段的查询场景，查询频度低的字段，单拆出来  

3.在1对多，需要关联统计的字段上，添加冗余字段。

##列选择原则： 
1.字段类型优先级 整型>date,time>enum,char>varchar>blob,text  
比如 tinyint 1,2,3,4,5 <-> char(1) a,b,c,d,e 
从空间上，都是占一个字节，但是order by排序，前者快。  
原因：后者需要考虑字符集与校对集(就是排序规则)  

time定长，运算快，节省空间。考虑时区，写sql时不方便 where '2005-10-12'   
enum:能起约束值的目的，内部用整形来存储，但与char联查询时候，内部要分字符串与值的转化  
char 定长，考虑字符集和(排序)校对集
varchar 不定长 要考虑字符集的转换与排序时的校对集，速度慢。
text/Blob 无法使用内存临时表(排序等操作只能在磁盘上进行)  

性别：以utf8为例
char(1),3个字长字节  
enum('男','女'); //内部转换成数字来存，多一个转换过程  
tinyint(),//0 1 2  //定长一个字节

2.够用就行，不要慷慨(如smallint,varchar(N))  
原因：大的字段浪费内存，影响速度。  
以年龄为例 tinytint unsigned not null 可以存储255岁，足够，用int浪费了3个字节。  
以varchar(10),varchar(300)存储的内容相同，但在表联查时，varchar(300)要花更多内存。  

3.要尽量避免使用NULL()  
原因：NULL不利于索引，要用特殊的字节来标注 
在磁盘上占据的空间其实更大(mysql5.7已对null做的改进，但查询仍是不便)  

#索引优化策略
##1.索引类型
1.1 B-tree索引
注：名叫btree索引，大的方面来看，都用到的平衡树，具体的实现上，各引擎稍有不同。  
比如，严格的说，NDB引擎，使用的是T-tree
myisam，innodb中，默认用B-tree索引  

但抽象一下---B-tree系统，可理解为“排好序的快速查找结构”  

1.2 hash索引  
  在memory表里默认是hash索引，hash的理论查询时间复杂为O（1）  
疑问：既然hash的查找如何高效，为什么不都用hash索引？  
答：  
1.hash函数计算后的结果，是随机的，如果是在磁盘上放置数据，  
比主键为id为例，那么随着id的增长，id对应的行，在磁盘上随机放置。  
2.不法对范围查询进行优化。    
3.无法利用前缀索引，比如在btree中，filed列的值“helloworld”，并加索引查询xx=helloworld自然可以利用索引，xx=hello，也可以利用索引（左前缀索引)  
因为hash（“helloworld”）和hash（“hello”），两者的关系仍为随机  
4.排序也无法优化  
5.必须回行，就是说，通过索引拿到数据位置，必须回到表中的数据。
