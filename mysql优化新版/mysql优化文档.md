#表的优化与列类型选择
##表的优化：
1.定长与变成分离  
如 id int，占4个字节，char(4)占4个字符长度，也是定长,time即每一个单元值的字节是固定的。  
核心且常用字段，宜建成定长，放在一张表。  

而varchar,text,blob，这种变成字段，适合单放一张表，用主键与核心表关联起来。 

2.常用字段和不常用字段要分离  
需要结合网站具体的业务来分析，分析字段的查询场景，查询频度低的字段，单拆出来  

3.在1对多，需要关联统计的字段上，添加冗余字段。

##列选择原则： 
1.字段类型优先级 整型>date,time>enum,char>varchar>blob,text  
比如 tinyint 1,2,3,4,5 <-> char(1) a,b,c,d,e 
从空间上，都是占一个字节，但是order by排序，前者快。  
原因：后者需要考虑字符集与校对集(就是排序规则)  

time定长，运算快，节省空间。考虑时区，写sql时不方便 where '2005-10-12'   
enum:能起约束值的目的，内部用整形来存储，但与char联查询时候，内部要分字符串与值的转化  
char 定长，考虑字符集和(排序)校对集
varchar 不定长 要考虑字符集的转换与排序时的校对集，速度慢。
text/Blob 无法使用内存临时表(排序等操作只能在磁盘上进行)  

性别：以utf8为例
char(1),3个字长字节  
enum('男','女'); //内部转换成数字来存，多一个转换过程  
tinyint(),//0 1 2  //定长一个字节

2.够用就行，不要慷慨(如smallint,varchar(N))  
原因：大的字段浪费内存，影响速度。  
以年龄为例 tinytint unsigned not null 可以存储255岁，足够，用int浪费了3个字节。  
以varchar(10),varchar(300)存储的内容相同，但在表联查时，varchar(300)要花更多内存。  

3.要尽量避免使用NULL()  
原因：NULL不利于索引，要用特殊的字节来标注 
在磁盘上占据的空间其实更大(mysql5.7已对null做的改进，但查询仍是不便)  

#索引优化策略
##1.索引类型
1.1 B-tree索引
注：名叫btree索引，大的方面来看，都用到的平衡树，具体的实现上，各引擎稍有不同。  
比如，严格的说，NDB引擎，使用的是T-tree
myisam，innodb中，默认用B-tree索引  

但抽象一下---B-tree系统，可理解为“排好序的快速查找结构”  

1.2 hash索引  
  在memory表里默认是hash索引，hash的理论查询时间复杂为O（1）  
疑问：既然hash的查找如何高效，为什么不都用hash索引？  
答：  
1.hash函数计算后的结果，是随机的，如果是在磁盘上放置数据，  
比主键为id为例，那么随着id的增长，id对应的行，在磁盘上随机放置。  
2.不法对范围查询进行优化。    
3.无法利用前缀索引，比如在btree中，filed列的值“helloworld”，并加索引查询xx=helloworld自然可以利用索引，xx=hello，也可以利用索引（左前缀索引)  
因为hash（“helloworld”）和hash（“hello”），两者的关系仍为随机  
4.排序也无法优化  
5.必须回行，就是说，通过索引拿到数据位置，必须回到表中的数据。

##聚蔟索引与非聚蔟索引  
Myisam与innodb引擎，索引文件的异同  
Innodb的主索引文件，直接存放该行数据，成为聚蔟索引，次索引指向对主键的引用.  
Myisam中，主索引和次索引，都指向物理行(磁盘位置)，是非聚蔟索引。  

注意innodb来说，  
1.主键索引既存储索引值，有在叶子中存储行的数据  
2.如果没有主键(primary key)，则会Unique Key做主键.  
3.如果没有unique，则系统生成一个内部的rowid做主键。  
4.像innodb中，主键的索引结构中，既存储了主键，又存储了行数据，这种结构称为“聚蔟索引”.	

##索引覆盖：
索引覆盖是指如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据，这种查询速度非常快，称为“索引覆盖”

##理想索引  
1.查询频繁  
2.区分度高 
3.长度小  
4.尽量能覆盖常用查询字段  

区分度高：100万用户，性别基本上男/女各为50W，区分度就低。  
索引长度直接影响索引文件的大小，影响增删改的速度，并间接影响查询速度（占用内存多）

针对列中的值，从左往右截取部分，来建索引   
1.截的越短，重复度越高，区分度越小，索引效果越不好。  
2.截的越长，重复度越低，区分度越高，索引效果越好，但带来的影响也越大-增删改变慢，并间影响查询速度。  

所以，我们要在区分度+长度两者上，取得一个平衡。  

惯用手法：截取不同长度，并测试其区分度。  


##多列索引
3.1多列索引的考虑因素-- 列的查询频率，列的区分度，列的查询顺序，注意一定要结合实际业务场景  
以eshop商城为例，goods表中的cat\_id，brand\_id做多列索引。

最终选择(1)index(cat\_id,band\_id),+index(cat\_id,shop\_price)来建立索引 
甚至可以加(3)index(cat\_id,brand\_id,shop\_price),3个冗于索引。  
但(3)中的前2列和(1)中的前2列一样，再去掉(1)  
index(cat\_id,price)和index(cat\_id,brand\_id,shop\_price)   

##索引与排序
1.对于覆盖索引，直接在索引查询时，就是有顺序的，using index，在innodb引擎中，沿着索引字段排序，也是自然有序的，对于Myisamy引擎，如果按某索引字段排序，如id，但取出的字段中，有未索引排序子段，如good_name，myisam的做法，不是索引->回行，所以->回行，而是先取出所有行，再进行排序。  
2.选取出数据，形成临时表filesort(文件排序，但文件可能在磁盘上，也可能在内存中)  

我们的争取目标---取出的数据本身就是有序的！利用索引来排序。  

##重复索引与冗于索引 
重复索引：是指在同1列(如age)，或者顺序相同的几个列(age,school)，建立了多个索引。成为重复索引。重复索引没有任何帮助，只会增大索引文件，拖慢更新速度，去掉。  

冗余索引：
冗余索引是指2个索引所覆盖的列有重叠，成为冗余索引。  
列有重叠，但顺序不一样，成为冗余索引，冗余索引常见。  

##索引碎片与维护  
在长期数据更改过程中，索引文件和数据文件，都将产生空洞，形成碎片。  
我们可以通过一个nop操作（不产生对数据实质影响的操作）,来修改表。  
比如：表的引擎为innodb，可以alter table xxx engine innodb.  

optimize表明，可以修复 

注意：修复表的数据及索引碎片，就会把所有的数据文件重复整理一遍，使之对齐。  
这个过程，如果表的行数比较大，也是非常耗费资源的操作。  
所以，不能频繁的修复。  

如果表的Update操作很频繁，可以按周/月来修复。   
如果不频繁，可以更长的周期来修复。  

##sql语句优化  
1.sql语句的时间花在哪儿？  
答：等待时间，执行时间  
这个两个时间并非孤立的，如果单条语句执行的快了，对其他语句的锁定也就少了。  
所以，我们来分析如何降低执行时间。  

2.sql语句的执行时间，又花在哪儿了？  
答：  
a.查找-->沿着索引查找，慢者可能全表扫描。  
b.取出-->查到行后，把数据取出来(sending data)

如何查询快?   
a.查询的快--联合索引的顺序，区分度，长度。  
b.取的快，索引覆盖。  
c.传输的少，更少的行和列。  

切分查询：按数据拆成多次。
例如：10000行数据，每1000条为单位，插入。  
分解查询：按逻辑把多表连接查询分成多个简单sql。  

3.sql语句的优化思路？
答：不查--少查--高效的查  
不查，通过业务逻辑来计算。  
比如论坛的注册会员数，我们可以根据3个月统计的每天注册数，用程序来估算。

少查：尽量精准数据，少取行。我们观察新闻网站，评论内容等。一般一次性取列表10-30条左右。  

必须要查，尽量走在索引上查询行。  

取时，取尽量少的列。
