#表的优化与列类型选择
##表的优化：
1.定长与变成分离  
如 id int，占4个字节，char(4)占4个字符长度，也是定长,time即每一个单元值的字节是固定的。  
核心且常用字段，宜建成定长，放在一张表。  

而varchar,text,blob，这种变成字段，适合单放一张表，用主键与核心表关联起来。 

2.常用字段和不常用字段要分离  
需要结合网站具体的业务来分析，分析字段的查询场景，查询频度低的字段，单拆出来  

3.在1对多，需要关联统计的字段上，添加冗余字段。

##列选择原则： 
1.字段类型优先级 整型>date,time>enum,char>varchar>blob,text  
比如 tinyint 1,2,3,4,5 <-> char(1) a,b,c,d,e 
从空间上，都是占一个字节，但是order by排序，前者快。  
原因：后者需要考虑字符集与校对集(就是排序规则)  

time定长，运算快，节省空间。考虑时区，写sql时不方便 where '2005-10-12'   
enum:能起约束值的目的，内部用整形来存储，但与char联查询时候，内部要分字符串与值的转化  
char 定长，考虑字符集和(排序)校对集
varchar 不定长 要考虑字符集的转换与排序时的校对集，速度慢。
text/Blob 无法使用内存临时表(排序等操作只能在磁盘上进行)  

性别：以utf8为例
char(1),3个字长字节  
enum('男','女'); //内部转换成数字来存，多一个转换过程  
tinyint(),//0 1 2  //定长一个字节

2.够用就行，不要慷慨(如smallint,varchar(N))  
原因：大的字段浪费内存，影响速度。  
以年龄为例 tinytint unsigned not null 可以存储255岁，足够，用int浪费了3个字节。  
以varchar(10),varchar(300)存储的内容相同，但在表联查时，varchar(300)要花更多内存。  

3.要尽量避免使用NULL()  
原因：NULL不利于索引，要用特殊的字节来标注 
在磁盘上占据的空间其实更大(mysql5.7已对null做的改进，但查询仍是不便)  

#索引优化策略
##1.索引类型
1.1 B-tree索引
注：名叫btree索引，大的方面来看，都用到
